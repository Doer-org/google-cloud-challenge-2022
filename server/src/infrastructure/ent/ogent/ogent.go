// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent"
	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent/authstates"
	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent/ecomment"
	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent/estate"
	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent/etype"
	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent/event"
	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent/googleauth"
	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent/loginsessions"
	"github.com/Doer-org/google-cloud-challenge-2022/infrastructure/ent/user"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateAuthStates handles POST /auth-states-slice requests.
func (h *OgentHandler) CreateAuthStates(ctx context.Context, req CreateAuthStatesReq) (CreateAuthStatesRes, error) {
	b := h.client.AuthStates.Create()
	// Add all fields.
	b.SetState(req.State)
	if v, ok := req.RedirectURL.Get(); ok {
		b.SetRedirectURL(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.AuthStates.Query().Where(authstates.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewAuthStatesCreate(e), nil
}

// ReadAuthStates handles GET /auth-states-slice/{id} requests.
func (h *OgentHandler) ReadAuthStates(ctx context.Context, params ReadAuthStatesParams) (ReadAuthStatesRes, error) {
	q := h.client.AuthStates.Query().Where(authstates.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewAuthStatesRead(e), nil
}

// UpdateAuthStates handles PATCH /auth-states-slice/{id} requests.
func (h *OgentHandler) UpdateAuthStates(ctx context.Context, req UpdateAuthStatesReq, params UpdateAuthStatesParams) (UpdateAuthStatesRes, error) {
	b := h.client.AuthStates.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.State.Get(); ok {
		b.SetState(v)
	}
	if v, ok := req.RedirectURL.Get(); ok {
		b.SetRedirectURL(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.AuthStates.Query().Where(authstates.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewAuthStatesUpdate(e), nil
}

// DeleteAuthStates handles DELETE /auth-states-slice/{id} requests.
func (h *OgentHandler) DeleteAuthStates(ctx context.Context, params DeleteAuthStatesParams) (DeleteAuthStatesRes, error) {
	err := h.client.AuthStates.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteAuthStatesNoContent), nil

}

// ListAuthStates handles GET /auth-states-slice requests.
func (h *OgentHandler) ListAuthStates(ctx context.Context, params ListAuthStatesParams) (ListAuthStatesRes, error) {
	q := h.client.AuthStates.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewAuthStatesLists(es)
	return (*ListAuthStatesOKApplicationJSON)(&r), nil
}

// CreateEState handles POST /e-states requests.
func (h *OgentHandler) CreateEState(ctx context.Context, req CreateEStateReq) (CreateEStateRes, error) {
	b := h.client.EState.Create()
	// Add all fields.
	b.SetName(req.Name)
	// Add all edges.
	b.SetEventID(req.Event)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.EState.Query().Where(estate.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEStateCreate(e), nil
}

// ReadEState handles GET /e-states/{id} requests.
func (h *OgentHandler) ReadEState(ctx context.Context, params ReadEStateParams) (ReadEStateRes, error) {
	q := h.client.EState.Query().Where(estate.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEStateRead(e), nil
}

// UpdateEState handles PATCH /e-states/{id} requests.
func (h *OgentHandler) UpdateEState(ctx context.Context, req UpdateEStateReq, params UpdateEStateParams) (UpdateEStateRes, error) {
	b := h.client.EState.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if v, ok := req.Event.Get(); ok {
		b.SetEventID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.EState.Query().Where(estate.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEStateUpdate(e), nil
}

// DeleteEState handles DELETE /e-states/{id} requests.
func (h *OgentHandler) DeleteEState(ctx context.Context, params DeleteEStateParams) (DeleteEStateRes, error) {
	err := h.client.EState.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteEStateNoContent), nil

}

// ListEState handles GET /e-states requests.
func (h *OgentHandler) ListEState(ctx context.Context, params ListEStateParams) (ListEStateRes, error) {
	q := h.client.EState.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEStateLists(es)
	return (*ListEStateOKApplicationJSON)(&r), nil
}

// ReadEStateEvent handles GET /e-states/{id}/event requests.
func (h *OgentHandler) ReadEStateEvent(ctx context.Context, params ReadEStateEventParams) (ReadEStateEventRes, error) {
	q := h.client.EState.Query().Where(estate.IDEQ(params.ID)).QueryEvent()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEStateEventRead(e), nil
}

// CreateEType handles POST /e-types requests.
func (h *OgentHandler) CreateEType(ctx context.Context, req CreateETypeReq) (CreateETypeRes, error) {
	b := h.client.EType.Create()
	// Add all fields.
	b.SetName(req.Name)
	// Add all edges.
	b.SetEventID(req.Event)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.EType.Query().Where(etype.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewETypeCreate(e), nil
}

// ReadEType handles GET /e-types/{id} requests.
func (h *OgentHandler) ReadEType(ctx context.Context, params ReadETypeParams) (ReadETypeRes, error) {
	q := h.client.EType.Query().Where(etype.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewETypeRead(e), nil
}

// UpdateEType handles PATCH /e-types/{id} requests.
func (h *OgentHandler) UpdateEType(ctx context.Context, req UpdateETypeReq, params UpdateETypeParams) (UpdateETypeRes, error) {
	b := h.client.EType.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if v, ok := req.Event.Get(); ok {
		b.SetEventID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.EType.Query().Where(etype.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewETypeUpdate(e), nil
}

// DeleteEType handles DELETE /e-types/{id} requests.
func (h *OgentHandler) DeleteEType(ctx context.Context, params DeleteETypeParams) (DeleteETypeRes, error) {
	err := h.client.EType.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteETypeNoContent), nil

}

// ListEType handles GET /e-types requests.
func (h *OgentHandler) ListEType(ctx context.Context, params ListETypeParams) (ListETypeRes, error) {
	q := h.client.EType.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewETypeLists(es)
	return (*ListETypeOKApplicationJSON)(&r), nil
}

// ReadETypeEvent handles GET /e-types/{id}/event requests.
func (h *OgentHandler) ReadETypeEvent(ctx context.Context, params ReadETypeEventParams) (ReadETypeEventRes, error) {
	q := h.client.EType.Query().Where(etype.IDEQ(params.ID)).QueryEvent()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewETypeEventRead(e), nil
}

// CreateEcomment handles POST /ecomments requests.
func (h *OgentHandler) CreateEcomment(ctx context.Context, req CreateEcommentReq) (CreateEcommentRes, error) {
	b := h.client.Ecomment.Create()
	// Add all fields.
	b.SetBody(req.Body)
	// Add all edges.
	if v, ok := req.Event.Get(); ok {
		b.SetEventID(v)
	}
	if v, ok := req.User.Get(); ok {
		b.SetUserID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Ecomment.Query().Where(ecomment.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEcommentCreate(e), nil
}

// ReadEcomment handles GET /ecomments/{id} requests.
func (h *OgentHandler) ReadEcomment(ctx context.Context, params ReadEcommentParams) (ReadEcommentRes, error) {
	q := h.client.Ecomment.Query().Where(ecomment.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEcommentRead(e), nil
}

// UpdateEcomment handles PATCH /ecomments/{id} requests.
func (h *OgentHandler) UpdateEcomment(ctx context.Context, req UpdateEcommentReq, params UpdateEcommentParams) (UpdateEcommentRes, error) {
	b := h.client.Ecomment.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Body.Get(); ok {
		b.SetBody(v)
	}
	// Add all edges.
	if v, ok := req.Event.Get(); ok {
		b.SetEventID(v)
	}
	if v, ok := req.User.Get(); ok {
		b.SetUserID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Ecomment.Query().Where(ecomment.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEcommentUpdate(e), nil
}

// DeleteEcomment handles DELETE /ecomments/{id} requests.
func (h *OgentHandler) DeleteEcomment(ctx context.Context, params DeleteEcommentParams) (DeleteEcommentRes, error) {
	err := h.client.Ecomment.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteEcommentNoContent), nil

}

// ListEcomment handles GET /ecomments requests.
func (h *OgentHandler) ListEcomment(ctx context.Context, params ListEcommentParams) (ListEcommentRes, error) {
	q := h.client.Ecomment.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEcommentLists(es)
	return (*ListEcommentOKApplicationJSON)(&r), nil
}

// ReadEcommentEvent handles GET /ecomments/{id}/event requests.
func (h *OgentHandler) ReadEcommentEvent(ctx context.Context, params ReadEcommentEventParams) (ReadEcommentEventRes, error) {
	q := h.client.Ecomment.Query().Where(ecomment.IDEQ(params.ID)).QueryEvent()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEcommentEventRead(e), nil
}

// ReadEcommentUser handles GET /ecomments/{id}/user requests.
func (h *OgentHandler) ReadEcommentUser(ctx context.Context, params ReadEcommentUserParams) (ReadEcommentUserRes, error) {
	q := h.client.Ecomment.Query().Where(ecomment.IDEQ(params.ID)).QueryUser()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEcommentUserRead(e), nil
}

// CreateEvent handles POST /events requests.
func (h *OgentHandler) CreateEvent(ctx context.Context, req CreateEventReq) (CreateEventRes, error) {
	b := h.client.Event.Create()
	// Add all fields.
	b.SetName(req.Name)
	if v, ok := req.Detail.Get(); ok {
		b.SetDetail(v)
	}
	if v, ok := req.Location.Get(); ok {
		b.SetLocation(v)
	}
	// Add all edges.
	if v, ok := req.State.Get(); ok {
		b.SetStateID(v)
	}
	if v, ok := req.Type.Get(); ok {
		b.SetTypeID(v)
	}
	b.AddUserIDs(req.Users...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Event.Query().Where(event.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEventCreate(e), nil
}

// ReadEvent handles GET /events/{id} requests.
func (h *OgentHandler) ReadEvent(ctx context.Context, params ReadEventParams) (ReadEventRes, error) {
	q := h.client.Event.Query().Where(event.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEventRead(e), nil
}

// UpdateEvent handles PATCH /events/{id} requests.
func (h *OgentHandler) UpdateEvent(ctx context.Context, req UpdateEventReq, params UpdateEventParams) (UpdateEventRes, error) {
	b := h.client.Event.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Detail.Get(); ok {
		b.SetDetail(v)
	}
	if v, ok := req.Location.Get(); ok {
		b.SetLocation(v)
	}
	// Add all edges.
	if v, ok := req.State.Get(); ok {
		b.SetStateID(v)
	}
	if v, ok := req.Type.Get(); ok {
		b.SetTypeID(v)
	}
	b.ClearUsers().AddUserIDs(req.Users...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Event.Query().Where(event.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEventUpdate(e), nil
}

// DeleteEvent handles DELETE /events/{id} requests.
func (h *OgentHandler) DeleteEvent(ctx context.Context, params DeleteEventParams) (DeleteEventRes, error) {
	err := h.client.Event.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteEventNoContent), nil

}

// ListEvent handles GET /events requests.
func (h *OgentHandler) ListEvent(ctx context.Context, params ListEventParams) (ListEventRes, error) {
	q := h.client.Event.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEventLists(es)
	return (*ListEventOKApplicationJSON)(&r), nil
}

// ReadEventState handles GET /events/{id}/state requests.
func (h *OgentHandler) ReadEventState(ctx context.Context, params ReadEventStateParams) (ReadEventStateRes, error) {
	q := h.client.Event.Query().Where(event.IDEQ(params.ID)).QueryState()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEventStateRead(e), nil
}

// ReadEventType handles GET /events/{id}/type requests.
func (h *OgentHandler) ReadEventType(ctx context.Context, params ReadEventTypeParams) (ReadEventTypeRes, error) {
	q := h.client.Event.Query().Where(event.IDEQ(params.ID)).QueryType()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEventTypeRead(e), nil
}

// ListEventUsers handles GET /events/{id}/users requests.
func (h *OgentHandler) ListEventUsers(ctx context.Context, params ListEventUsersParams) (ListEventUsersRes, error) {
	q := h.client.Event.Query().Where(event.IDEQ(params.ID)).QueryUsers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEventUsersLists(es)
	return (*ListEventUsersOKApplicationJSON)(&r), nil
}

// CreateGoogleAuth handles POST /google-auths requests.
func (h *OgentHandler) CreateGoogleAuth(ctx context.Context, req CreateGoogleAuthReq) (CreateGoogleAuthRes, error) {
	b := h.client.GoogleAuth.Create()
	// Add all fields.
	b.SetUserID(req.UserID)
	b.SetAccessToken(req.AccessToken)
	b.SetRefreshToken(req.RefreshToken)
	b.SetExpiry(req.Expiry)
	// Add all edges.
	b.SetUserID(req.User)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.GoogleAuth.Query().Where(googleauth.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGoogleAuthCreate(e), nil
}

// ReadGoogleAuth handles GET /google-auths/{id} requests.
func (h *OgentHandler) ReadGoogleAuth(ctx context.Context, params ReadGoogleAuthParams) (ReadGoogleAuthRes, error) {
	q := h.client.GoogleAuth.Query().Where(googleauth.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGoogleAuthRead(e), nil
}

// UpdateGoogleAuth handles PATCH /google-auths/{id} requests.
func (h *OgentHandler) UpdateGoogleAuth(ctx context.Context, req UpdateGoogleAuthReq, params UpdateGoogleAuthParams) (UpdateGoogleAuthRes, error) {
	b := h.client.GoogleAuth.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UserID.Get(); ok {
		b.SetUserID(v)
	}
	if v, ok := req.AccessToken.Get(); ok {
		b.SetAccessToken(v)
	}
	if v, ok := req.RefreshToken.Get(); ok {
		b.SetRefreshToken(v)
	}
	if v, ok := req.Expiry.Get(); ok {
		b.SetExpiry(v)
	}
	// Add all edges.
	if v, ok := req.User.Get(); ok {
		b.SetUserID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.GoogleAuth.Query().Where(googleauth.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGoogleAuthUpdate(e), nil
}

// DeleteGoogleAuth handles DELETE /google-auths/{id} requests.
func (h *OgentHandler) DeleteGoogleAuth(ctx context.Context, params DeleteGoogleAuthParams) (DeleteGoogleAuthRes, error) {
	err := h.client.GoogleAuth.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteGoogleAuthNoContent), nil

}

// ListGoogleAuth handles GET /google-auths requests.
func (h *OgentHandler) ListGoogleAuth(ctx context.Context, params ListGoogleAuthParams) (ListGoogleAuthRes, error) {
	q := h.client.GoogleAuth.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewGoogleAuthLists(es)
	return (*ListGoogleAuthOKApplicationJSON)(&r), nil
}

// ReadGoogleAuthUser handles GET /google-auths/{id}/user requests.
func (h *OgentHandler) ReadGoogleAuthUser(ctx context.Context, params ReadGoogleAuthUserParams) (ReadGoogleAuthUserRes, error) {
	q := h.client.GoogleAuth.Query().Where(googleauth.IDEQ(params.ID)).QueryUser()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGoogleAuthUserRead(e), nil
}

// CreateLoginSessions handles POST /login-sessions-slice requests.
func (h *OgentHandler) CreateLoginSessions(ctx context.Context, req CreateLoginSessionsReq) (CreateLoginSessionsRes, error) {
	b := h.client.LoginSessions.Create()
	// Add all fields.
	b.SetUserID(req.UserID)
	// Add all edges.
	b.SetUserID(req.User)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.LoginSessions.Query().Where(loginsessions.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewLoginSessionsCreate(e), nil
}

// ReadLoginSessions handles GET /login-sessions-slice/{id} requests.
func (h *OgentHandler) ReadLoginSessions(ctx context.Context, params ReadLoginSessionsParams) (ReadLoginSessionsRes, error) {
	q := h.client.LoginSessions.Query().Where(loginsessions.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewLoginSessionsRead(e), nil
}

// UpdateLoginSessions handles PATCH /login-sessions-slice/{id} requests.
func (h *OgentHandler) UpdateLoginSessions(ctx context.Context, req UpdateLoginSessionsReq, params UpdateLoginSessionsParams) (UpdateLoginSessionsRes, error) {
	b := h.client.LoginSessions.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UserID.Get(); ok {
		b.SetUserID(v)
	}
	// Add all edges.
	if v, ok := req.User.Get(); ok {
		b.SetUserID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.LoginSessions.Query().Where(loginsessions.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewLoginSessionsUpdate(e), nil
}

// DeleteLoginSessions handles DELETE /login-sessions-slice/{id} requests.
func (h *OgentHandler) DeleteLoginSessions(ctx context.Context, params DeleteLoginSessionsParams) (DeleteLoginSessionsRes, error) {
	err := h.client.LoginSessions.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteLoginSessionsNoContent), nil

}

// ListLoginSessions handles GET /login-sessions-slice requests.
func (h *OgentHandler) ListLoginSessions(ctx context.Context, params ListLoginSessionsParams) (ListLoginSessionsRes, error) {
	q := h.client.LoginSessions.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewLoginSessionsLists(es)
	return (*ListLoginSessionsOKApplicationJSON)(&r), nil
}

// ReadLoginSessionsUser handles GET /login-sessions-slice/{id}/user requests.
func (h *OgentHandler) ReadLoginSessionsUser(ctx context.Context, params ReadLoginSessionsUserParams) (ReadLoginSessionsUserRes, error) {
	q := h.client.LoginSessions.Query().Where(loginsessions.IDEQ(params.ID)).QueryUser()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewLoginSessionsUserRead(e), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	if v, ok := req.Age.Get(); ok {
		b.SetAge(v)
	}
	b.SetName(req.Name)
	b.SetAuthenticated(req.Authenticated)
	if v, ok := req.Mail.Get(); ok {
		b.SetMail(v)
	}
	b.SetIcon(req.Icon)
	// Add all edges.
	b.AddEventIDs(req.Events...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Age.Get(); ok {
		b.SetAge(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Authenticated.Get(); ok {
		b.SetAuthenticated(v)
	}
	if v, ok := req.Mail.Get(); ok {
		b.SetMail(v)
	}
	if v, ok := req.Icon.Get(); ok {
		b.SetIcon(v)
	}
	// Add all edges.
	b.ClearEvents().AddEventIDs(req.Events...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ListUserEvents handles GET /users/{id}/events requests.
func (h *OgentHandler) ListUserEvents(ctx context.Context, params ListUserEventsParams) (ListUserEventsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryEvents()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserEventsLists(es)
	return (*ListUserEventsOKApplicationJSON)(&r), nil
}
